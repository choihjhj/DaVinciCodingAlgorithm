# 풀이) DFS
import sys
sys.setrecursionlimit(10**4)
N=int(sys.stdin.readline().rstrip())
M=int(sys.stdin.readline().rstrip())

arr=[[] for _ in range(N+1)] #맨앞 빈배열[]
for _ in range(M):
  u, v = map(int, sys.stdin.readline().rstrip().split())
  arr[u].append(v)
  arr[v].append(u)

visited = [False] * (N + 1)
cnt=0
def dfs(node):
    visited[node] = True
    global cnt
    for next_node in arr[node]:
        if not visited[next_node]:
            dfs(next_node)
            cnt+=1
dfs(1)
print(cnt)

# 풀이2) BFS
import sys
from collections import deque
N=int(sys.stdin.readline().rstrip())
M=int(sys.stdin.readline().rstrip())

arr=[[] for _ in range(N+1)] #맨앞 빈배열[]
for _ in range(M):
  u, v = map(int, sys.stdin.readline().rstrip().split())
  arr[u].append(v)
  arr[v].append(u)

visited = [False] * (N + 1)
cnt=0
def bfs(node):
    dq=deque([node])
    global cnt
    while dq:     
      for next_node in arr[dq.popleft()]:
          if not visited[next_node]:
              dq.append(next_node)
              cnt+=1

bfs(1)
print(cnt)

#///////
from collections import deque

n = int(input())
connect = int(input())
graph = [[] for i in range(n+1)]  #1
visited = [False]*(n+1)
cnt = 0

for i in range(connect):
    s, e = map(int, input().split())
    #2 네트워크 상 연결 : 양방향
    graph[s].append(e)
    graph[e].append(s)

def bfs(graph, v):
    global cnt
    queue = deque([v])  #3

    while queue:  #4
        pop = queue.popleft()  #5
        visited[pop] = True

        for i in graph[pop]:
            if visited[i]==False:
                visited[i] = True
                queue.append(i)  #6
                cnt += 1  #7
    print(cnt)

bfs(graph, 1)
출처: https://hei-jayden.tistory.com/103 [알음알음 성장로그:티스토리]
